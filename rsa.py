# -*- coding: utf-8 -*-
"""BitVectorDemo.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NoLVEBqkvrHwoYoEuxX0BeJvaJ5MtVrA
"""

# !pip install BitVector


"""Tables"""

from math import ceil,floor
import copy
from BitVector import *
import time
import pickle
import random

class RSA :

	def __init__(self,client_id=0):
		self.client_id=client_id
		self.keys = {}
		self.ciphertext = []
		
		
	def gcd(self,p,q):
		while q!=0:
			p,q=q,p%q
		return p

	def coprime(self,e,phi):
		return self.gcd(e,phi)==1

	def power(self,x, y, p):
		
		# Initialize result
		res = 1
		
		# Update x if it is more than or
		# equal to p
		x = x % p
		while (y > 0):
			
			# If y is odd, multiply
			# x with result
			if (y & 1):
				res = (res * x) % p

			# y must be even now
			y = y>>1 # y = y/2
			x = (x * x) % p
		
		return res


	def encrypt(self,P,public_key):
		e = public_key[0]
		n = public_key[1]
		return self.power(P,e,n)

	def decrypt(self,C,private_key):
		d = private_key[0]
		n = private_key[1]
		return self.power(C,d,n)
	
	def generateKeys(self,key_length=32) :
		self.key_length = key_length
		iter = 4
		primes = []
		k=int(self.key_length/2)

		for n in range(int(2**(k-1)),int((2**k)-1)):
			bv = BitVector(intVal = n)
			check = bv.test_for_primality()
			if check>0.7:
				primes.append(n)
				if len(primes)==2 :
					break
		self.p = primes[0]
		self.q = primes[1]
		self.n=self.p*self.q
		self.phi = (self.p-1)*(self.q-1)

		e = 2
		for i in range(2,self.phi):
			if self.coprime(i,self.phi):
				e=i
				break
		self.e = e

		ebv = BitVector(intVal=self.e)
		phibv = BitVector(intVal=self.phi)
		self.d = ebv.multiplicative_inverse(phibv).int_val()

		self.keys = {'public' : (self.e,self.n),'private': (self.d,self.n)}
		
		with open('public'+str(self.client_id)+'.pkl', 'wb') as f:
			pickle.dump(self.keys['public'], f)
		
		with open('private'+str(self.client_id)+'.pkl', 'wb') as f:
			pickle.dump(self.keys['private'], f)

	
	def setPublicKey(self,pickle_file_path):
		with open(pickle_file_path, 'rb') as f:
			my_object = pickle.load(f)
			self.keys['public'] = my_object
	
	def setPrivateKey(self,pickle_file_path):
		with open(pickle_file_path, 'rb') as f:
			my_object = pickle.load(f)
			self.keys['private'] = my_object
	
	def setPlainText(self,plain_text):
		self.plaintext = plain_text
	
	def createCipher(self):
		self.ciphertext = []
		for i in range(len(self.plaintext)):
			if isinstance(self.plaintext, str):
				self.ciphertext.append(self.encrypt(ord(self.plaintext[i]),self.keys['public']))
			else :
				self.ciphertext.append(self.encrypt(self.plaintext[i],self.keys['public']))
	
	def decipher(self):
		self.decryptedtext = []
		for i in range(len(self.ciphertext)):
			self.decryptedtext.append(self.decrypt(self.ciphertext[i],self.keys['private']))
	
	def createDecipheredText(self):
		self.decipheredtext = ""
		for i in range(len(self.decryptedtext)):
			self.decipheredtext += chr(self.decryptedtext[i])
	
	def EncryptionDecryption(self):
		self.generateKeys()
		self.createCipher()
		self.decipher()




# Driver Code

# key_length = int(input("input key length :"))
# plaintext = input("plain text :")
# rsa = RSA() 
# rsa.setPlainTextKeyLength(plaintext,key_length)
# rsa.EncryptionDecryption()

# print("Generated keys")
# print(rsa.keys)

# print("Cipher Text:")
# print(rsa.ciphertext)

# print("Decrypted Text:")
# print(rsa.decryptedtext)

#time related performance
# plaintext = input("plain text :")
# key_lengths = [16,32,64,128]
# timetable = {16:{}, 32:{}, 64:{}, 128:{} }

# for key_length in key_lengths:
# 	rsa = RSA() 
# 	rsa.setPlainTextKeyLength(plaintext,key_length)
# 	times = {}

# 	start_time = time.time()
# 	rsa.generateKeys()
# 	end_time = time.time()
# 	times['Key Generation'] = end_time-start_time

# 	start_time = time.time()
# 	rsa.createCipher()
# 	end_time = time.time()
# 	times['Encryption'] = end_time-start_time

# 	start_time = time.time()
# 	rsa.decipher()
# 	end_time = time.time()
# 	times['Decryption'] = end_time-start_time

# 	timetable[key_length] = times
# print(timetable)

